# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Convert a SAX series to another SAX series with chosen group size.
#' @title DMarkov Convert (convert)
#' @param data A vector containing the SAX series to be converted
#' @param groupSize The chosen group size for sampling from original series
#' @param alphabetSize The original alphabet size of the inputted SAX data
#' @return A vector containing the new SAX series of alphabet size 'alphabetSize'^'groupSize'
#' @export
convert <- function(data, groupSize, alphabetSize) {
    .Call('rspatiotemp_convert', PACKAGE = 'rspatiotemp', data, groupSize, alphabetSize)
}

#' Create new ProbMatX object from a set of observed and hidden data. This ProbMatX object contains transition, emission and reverse emission probabilities
#' @title Create Probability Matrix X (createProbMatX)
#' @param dataO A vector containing the observed data in SAX
#' @param dataH A vector containing the hidden data in SAX
#' @param groupSize The chosen group size for DMarkov
#' @param alphabetSizeO The original alphabet size of the observed data
#' @param alphabetSizeH The original alphabet size of the hidden data
#' @return A ProbMatX object. A list containing the transition, emission and reverse emission probabilities trained from the input data
#' @export
createProbMatX <- function(dataO, dataH, groupSize, alphabetSizeO, alphabetSizeH) {
    .Call('rspatiotemp_createProbMatX', PACKAGE = 'rspatiotemp', dataO, dataH, groupSize, alphabetSizeO, alphabetSizeH)
}

#' Update ProbMatX object with more data
#' @title Update Probability Matrix X (updateProbMatX)
#' @param prevData The ProbMatX object created from 'createProbMatX' function
#' @param dataO the new observed data to be updated into the ProbMatX object
#' @param dataH the new hidden data to be updated into the ProbMatX object
#' @param groupSize The chosen group size for DMarkov. The groupSize must be the same as the one used when creating the ProbMatX object
#' @param alphabetSizeO The original alphabet size of the observed data. The alphabetSize must be the same as the one used when creating the ProbMatX object
#' @param alphabetSizeH The original alphabet size of the hidden data. The alphabetSize must be the same as the one used when creating the ProbMatX object
#' @return A ProbMatX object. A list containing the updated transition, emission and reverse emission probabilities from the input data
#' @export
updateProbMatX <- function(prevData, dataO, dataH, groupSize, alphabetSizeO, alphabetSizeH) {
    .Call('rspatiotemp_updateProbMatX', PACKAGE = 'rspatiotemp', prevData, dataO, dataH, groupSize, alphabetSizeO, alphabetSizeH)
}

#' Simulate hidden series given an observed series and using the reverse emission probability from ProbMatX object
#' @title Simulate Hidden Series (simulateHid)
#' @param probMatX The ProbMatX object created from 'createProbMatX' function
#' @param dataObs The observed data used to simulate the hidden data
#' @param groupSize The groupSize of the DMarkov model. Should be the same as the one used to create ProbMatX object
#' @param alphabetSizeO The original alphabet size of the observed data. The alphabetSize must be the same as the one used when creating the ProbMatX object
#' @param alphabetSizeH The original alphabet size of the hidden data. The alphabetSize must be the same as the one used when creating the ProbMatX object
#' @return A vector containing the simulated hidden data
#' @export
simulateHid <- function(probMatX, dataObs, groupSize, alphabetSizeO, alphabetSizeH) {
    .Call('rspatiotemp_simulateHid', PACKAGE = 'rspatiotemp', probMatX, dataObs, groupSize, alphabetSizeO, alphabetSizeH)
}

#' Forward algorithm for hidden markov models.
#' @title Forward Algorithm (forward)
#' @param transProb A matrix containing the transition probabilites from the hidden markov model
#' @param emisProb A matrix containing the emission probabilities from the hidden markov model
#' @param initProb A matrix containing the initial probabilities from the hidden markov model
#' @param dataO A vector containing the observed sequence of data
#' @param dataH A single symbol of the hidden data
#' @param indexH The index at which the single symbol of hidden data above is located in it's original sequence
#' @return A double(real) value. The probability that the hidden symbol is at 'indexH' given the observed sequence and probabilitiy matrices
#' @export
forward <- function(transProb, emisProb, initProb, dataO, dataH, indexH) {
    .Call('rspatiotemp_forward', PACKAGE = 'rspatiotemp', transProb, emisProb, initProb, dataO, dataH, indexH)
}

#' Compute the probability of that the given observed and hidden sequences occur in a trained system
#' @title Viterbi Probability Value (viterbiProbVal)
#' @param transProb A matrix containing the transition probabilites from the hidden markov model
#' @param emisProb A matrix containing the emission probabilities from the hidden markov model
#' @param initProb A matrix containing the initial probabilities from the hidden markov model
#' @param dataO A vector containing the observed sequence of data
#' @param dataH A vector containing the hidden sequence of data
#' @return A vector containing the probability to get to each index of the hidden state given the observed state
#' @export
viterbiProbVal <- function(transProb, emisProb, initProb, dataO, dataH, logLand = FALSE) {
    .Call('rspatiotemp_viterbiProbVal', PACKAGE = 'rspatiotemp', transProb, emisProb, initProb, dataO, dataH, logLand)
}

maxVec <- function(data) {
    .Call('rspatiotemp_maxVec', PACKAGE = 'rspatiotemp', data)
}

#' @export
probObsLog <- function(transProb, emisProb, dataO) {
    .Call('rspatiotemp_probObsLog', PACKAGE = 'rspatiotemp', transProb, emisProb, dataO)
}

#' Determine the most probable hidden sequence given an observed sequence
#' @param transProb A matrix containing the transition probabilites from the hidden markov model
#' @param emisProb A matrix containing the emission probabilities from the hidden markov model
#' @param initProb A matrix containing the initial probabilities from the hidden markov model
#' @param dataV A vector containing the observed sequence of data
#' @return A vector containing the most probable sequence of hidden states
#' @export
viterbi <- function(transProb, emisProb, initProb, dataV) {
    .Call('rspatiotemp_viterbi', PACKAGE = 'rspatiotemp', transProb, emisProb, initProb, dataV)
}

#' Train Hidden Markov model
#' @title Train (train)
#' @param transProb A matrix containing the transition probabilites from the hidden markov model
#' @param emisProb A matrix containing the emission probabilities from the hidden markov model
#' @param initProb A matrix containing the initial probabilities from the hidden markov model
#' @param dataV A vector containing the observed sequence of data
#' @return A list of new probability matrices
#' @export
train <- function(transProb, emisProb, initProb, dataV) {
    .Call('rspatiotemp_train', PACKAGE = 'rspatiotemp', transProb, emisProb, initProb, dataV)
}

vValue <- function(vH, vV, weight, lambda) {
    .Call('rspatiotemp_vValue', PACKAGE = 'rspatiotemp', vH, vV, weight, lambda)
}

#' Compute the accumulated degradation at each time interval.
#' Accumulated Degradation (accDegrad)
#' @param dataH A matrix containing the horizontal vibration data.
#' @param dataV A matrix containing the vertival vibration data.
#' @param alpha A choosen constant value used when computing the R value. The R value takes into account the influence of the time.
#' @param beta A choosen constant value used when computing the F value. The F value takes into account the influence of the acceleration.
#' @param weight The weight must be less or equal to 1. It is the percent weight of the horizontal data.
#' @param rType The method used to compute the R value. See details for more details.
#' @param fType The method used to compute the F value. See details for more details.
#' @param onlyFinal Default to false. If true returns only the final accumulated degradtion value.
#' @return A vector containing all the accumulated degradation values at each time interval.
#' @details rType: \cr
#' "exp" = Exponential [R = e^(alpha*(t-i))] \cr
#' "Nexp" = Normalized Exponential [R = t*e^(alpha*(t-i)/[sum k(1:t)]e^(alpha(t-k)))] \cr
#' "poly1" = Polynomial 1 [R = (i/t)^alpha] \cr
#' "poly2" = Polynomial 2 [R = (t-i+1)^alpha] \cr
#' "Npoly1" = Normalized Polynomial 1 [R = t*(i/t)^alpha/[sum k(1:t)](i/t)^alpha] \cr
#' "Npoly2" = Normalized Polynomial 2 [R = t*(t-i+1)^alpha/[sum k(1:t)](t-i+1)^alpha]\cr \cr
#' fType: \cr
#' "poly" = Polynomial [F = V(i,j)^beta]
#' "Npoly" = Normalized Polynomial [F = ([sum j(1:data length)]V(i,j)^beta/datalength)^(1/beta)]
#' @export
accDegrad <- function(dataH, dataV, alpha, beta, lambda, weight, rType, fType, onlyFinal = FALSE) {
    .Call('rspatiotemp_accDegrad', PACKAGE = 'rspatiotemp', dataH, dataV, alpha, beta, lambda, weight, rType, fType, onlyFinal)
}

#' Create a Life Table comparing the accumulated Degradation to the time remaining
#' @title Create Life Table (createLifeTab)
#' @param accDeg The output of the 'accDegrad' function. A vector containing the Accumulated Degredation values of the time series data.
#' @param timeInterval The interval of time inbetween each sample of data.
#' @return A Life Table used for RUL computation
#' @export
createLifeTab <- function(accDeg, timeInterval) {
    .Call('rspatiotemp_createLifeTab', PACKAGE = 'rspatiotemp', accDeg, timeInterval)
}

#' Updates Life Table produced from 'createLifeTab' function
#' @title Update Life Table (updateLifeTab)
#' @param lifeTab The life table created from createLifeTab or updateLifeTab.
#' @param accDeg The output of the 'accDegrad' function. A vector containing the Accumulated Degredation values of the time series data.
#' @return A Life Table used for RUL computation.
#' @export
updateLifeTab <- function(lifeTab, accDeg) {
    .Call('rspatiotemp_updateLifeTab', PACKAGE = 'rspatiotemp', lifeTab, accDeg)
}

#' Determines the Remaining useful life of a system based on its accumulated degradation value
#' @title Compute Remaining Useful Life (computeRUL)
#' @param lifeTab The life table created from createLifeTab or updateLifeTab.
#' @param accDegVal The final accumulated degredation value of your data.
#' @return The estimated remaining useful life of the system.
#' @export
computeRUL <- function(lifeTab, accDegVal) {
    .Call('rspatiotemp_computeRUL', PACKAGE = 'rspatiotemp', lifeTab, accDegVal)
}

#' @export
meanAndStd <- function(probMatX) {
    .Call('rspatiotemp_meanAndStd', PACKAGE = 'rspatiotemp', probMatX)
}

#' Computes nodal energy of a single column of a WPD. Called by the 'getEnergy' function.
#' @title Compute single nodal energy (nodeEnergy)
#' @param node A NumericVector containing a single column of the WPD values.
#' @param size The length of each column.
#' @return The nodal energy value of that column of the WPD.
NULL

#' Compute nodal energy of a WPD.
#' @title Compute nodal energy (getEnergy)
#' @param wpdData A NumericMatrix containing the WPD.
#' @return A vector of the nodal energy valyes of the WPD.
#' @export
getEnergy <- function(wpdData) {
    .Call('rspatiotemp_getEnergy', PACKAGE = 'rspatiotemp', wpdData)
}

#' Group viterbi sequence values accordingly for mean and stdDev calculation
#' @title Format Viterbi Sequence (formatRULHMM)
#' @param seq The viterbi sequence to be formatted
#' @return A list of the reduced sequence and the repeat sequence. The formatted sequence.
#' @export
formatRULHMM <- function(seq) {
    .Call('rspatiotemp_formatRULHMM', PACKAGE = 'rspatiotemp', seq)
}

#' Compute the mean and standard deviation of the formatted viterbi sequence.
#' @title Mean and StdDev of viterbi (meanStdDev)
#' @param redSeq The reduced viterbi sequence from the 'formatRULHMM' function.
#' @param repSeq The repeat viterbi sequence from the 'formatRULHMM' function.
#' @param hidAlphabetSize The alphabet size of the hidden sequence.
#' @param tab Whether or not you are using *.tab functions.
#' @return The mean and standard deviation vectors for each state.
#' @export
meanStdDev <- function(redSeq, repSeq, hidAlphabetSize, tab = FALSE) {
    .Call('rspatiotemp_meanStdDev', PACKAGE = 'rspatiotemp', redSeq, repSeq, hidAlphabetSize, tab)
}

#' Finding the critical path from a start state to an end state given the transition probabilities.
#' @title Find Critical Path (criticalPath)
#' @param transProb A NumericMatrix of the transition probabilities.
#' @param startState The beginning state in the path.
#' @param endState The ending state in the path.
#' @param possibleStates A vector containing the possible states in the path.
#' @return A vector containing the critical path. The most probably path from the start state to the end state where each state is visited at most once.
#' @export
criticalPath <- function(transProb, startState, endState, possibleStates) {
    .Call('rspatiotemp_criticalPath', PACKAGE = 'rspatiotemp', transProb, startState, endState, possibleStates)
}

#' Compute the RUL and it's upper and lower bounds.
#' @title Compute RUL and bounds (computeRULBounds)
#' @param criticalSeq The critical path from the 'criticalPath' function.
#' @param meanVec The mean vector from the 'meanStdDev' function.
#' @param stdDev The standard deviation vector from the 'meanStdDev' function.
#' @param confCoef A confidence constant used for the computation of the upper and lower bounds.
#' @return The estimated RUL and its lower and upper bounds.
#' @export
computeRULBounds <- function(criticalSeq, meanVec, stdDev, confCoef) {
    .Call('rspatiotemp_computeRULBounds', PACKAGE = 'rspatiotemp', criticalSeq, meanVec, stdDev, confCoef)
}

#' Compute the probability of that the given continuous observed and discrete hidden sequences occuring in a trained system.
#' @title Viterbi Probability Value (viterbiProbVal)
#' @param transProb A matrix containing the transition probabilites from the hidden markov model.
#' @param emisProb A matrix containing the emission probabilities from the hidden markov model.
#' @param obsSeq A vector containing the observed sequence of data.
#' @param hidSeq A vector containing the hidden sequence of data.
#' @return The probability of the given continous observed and discrete hidden sequences occuring in a trained system.
#' @export
viterbiProbDepmix <- function(transProb, emisProb, obsSeq, hidSeq) {
    .Call('rspatiotemp_viterbiProbDepmix', PACKAGE = 'rspatiotemp', transProb, emisProb, obsSeq, hidSeq)
}

#' @export
viterbiCont <- function(transProb, emisProb, obsSeq) {
    .Call('rspatiotemp_viterbiCont', PACKAGE = 'rspatiotemp', transProb, emisProb, obsSeq)
}

#' Convert a time series into a SAX Word.
#' @title Convert to SAX (runSAX)
#' @param orgData A vector of time series data to be converted to a SAX Word.
#' @param segmentSize The size of each segment taken when converting to SAX Word.
#' @param alphabetSize The size of the alphabet for classification of PAAs to SAX Words.
#' @param iSAX False: returns only the SAX Word. True: returns SAX Word and Cardinality.
#' @return A Vector that contains the SAX Word and if iSAX = true a Vector that contains its corresponding Cardinality.
#' @export
runSAX <- function(orgData, segmentSize, alphabetSize, iSAX = FALSE) {
    .Call('rspatiotemp_runSAX', PACKAGE = 'rspatiotemp', orgData, segmentSize, alphabetSize, iSAX)
}

runNormData <- function(data) {
    .Call('rspatiotemp_runNormData', PACKAGE = 'rspatiotemp', data)
}

runToPAA <- function(data, segSize) {
    .Call('rspatiotemp_runToPAA', PACKAGE = 'rspatiotemp', data, segSize)
}

runToSAX <- function(data, brkPtNum) {
    .Call('rspatiotemp_runToSAX', PACKAGE = 'rspatiotemp', data, brkPtNum)
}

#' Count the number of times an Observed state 'm' is followed by a Hidden Symbol 'n'
#' @title Count Occurrences (count)
#' @param dataO A vector containing observed data
#' @param dataH A vector containing hidden data
#' @param oSize The alphabet size/cardinality of the observed data
#' @param hSize The alphabet size/cardinality of the hidden data
#' @return A NumericMatrix of times each combination of Observed followed by Hidden has occured
#' @export
count <- function(dataO, dataH, oSize, hSize) {
    .Call('rspatiotemp_count', PACKAGE = 'rspatiotemp', dataO, dataH, oSize, hSize)
}

#' A causality measurement between two sets of data
#' @title Causality Measurement (cosMeasure)
#' @param tabTrained A NumericMatrix returned from the 'count' function for the "training" data
#' @param testObs A vector containing the test observed data
#' @param testHid A vector containing the test hidden data
#' @param testOSize The alphabet size/cardinality of the observed data
#' @param testHSize The alphabet size/cardinality of the hidden data
#' @export
cosMeasure <- function(tabTrained, testObs, testHid, testOSize, testHSize) {
    .Call('rspatiotemp_cosMeasure', PACKAGE = 'rspatiotemp', tabTrained, testObs, testHid, testOSize, testHSize)
}

#' Compute the causality measurement between several subsequences and a trained set of data
#' @title Compute Distribution (distribution)
#' @param tabTrained Trained count matrix created from 'count' function
#' @param testObs A vector containing the test observed data
#' @param testHid A vector containing the test hidden data
#' @param testOSize The alphabet size of the observed data
#' @param testHSize The alphabet size of the hidden data
#' @param step The step size for subsequence sampling
#' @param subSeqSize The size of each subsequence extracted from test sequence
#' @return A vector containing the causality measurement (Lambda) of the several small subsequences sampled
#' @export
distribution <- function(tabTrained, testObs, testHid, testOSize, testHSize, step, subSeqSize) {
    .Call('rspatiotemp_distribution', PACKAGE = 'rspatiotemp', tabTrained, testObs, testHid, testOSize, testHSize, step, subSeqSize)
}

#' Compute energy of a binary vector of visible data and a binary vector of hidden data
#' @title Energy (E)
#' @param v A vector containing the binary visible data
#' @param h A vector containing the binary hidden data
#' @param a A vector containing the bias values for the visible data
#' @param b A vector containing the bias values for the hidden data
#' @param w A matrix containing the weights between the visible and hidden data
#' @return A double value. The energy of the binary vector of visible data and binary vector of hidden data
#' @export
E <- function(v, h, a, b, w) {
    .Call('rspatiotemp_E', PACKAGE = 'rspatiotemp', v, h, a, b, w)
}

#' Compute free energy of a binary vector of visible data for all possible hidden data of chosen size
#' @title Free Energy (F)
#' @param v A vector containing the binary visible data
#' @param hSize The size of vector containing the hidden data
#' @param a A vector containing the bias values for the visible data
#' @param b A vector containing the bias values for the hidden data
#' @param w A matrix containing the weights between the visible and hidden data
#' @return A double value. The free energy for that vector of visible data
#' @export
F <- function(v, hSize, a, b, w) {
    .Call('rspatiotemp_F', PACKAGE = 'rspatiotemp', v, hSize, a, b, w)
}

